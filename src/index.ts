import { app, BrowserWindow, dialog, ipcMain } from 'electron';
import * as path from "path";
import {spawn, execFile} from "child_process"
import {DeferredPromise} from "./DeferredPromise";

declare global {
  type FileOutput = {
    num_lines: number,
    num_chars: number,
    num_letters: number,
  }
  type FileNameCallback = (fileName: string) => void
  type FileOutputCallback = (fileOutput: FileOutput) => void

  interface Window {
    electronAPI: {
      openFile: (
            // fileNameCallback: FileNameCallback,
            // fileOutputCallback: FileOutputCallback
      ) => Promise<[DeferredPromise<string>, DeferredPromise<FileOutput>]>,// void
      selectFile: () => Promise<{file_path: string, file_name: string}>,
      processFile: (filePath: string) => Promise<FileOutput>,
    }
  }
}

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: any;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  // eslint-disable-line global-require
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    }
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY).then();

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// const handleFileOpen = async (
//     event: Electron.IpcMainInvokeEvent,
//     fileNameCallback: FileNameCallback,
//     fileOutputCallback: FileOutputCallback) => {
//   const {canceled, filePaths} = await dialog.showOpenDialog({
//   })
//
//   if (canceled) {
//     fileNameCallback(null);
//     fileOutputCallback(null);
//     return;
//   }
//
//   const absolute_file_path = filePaths[0]
//   fileNameCallback(path.basename(absolute_file_path))
//
//   //spawn('./python_code/dist/simple', )
//   execFile('./python_code/dist/file_processor', [absolute_file_path],
//       (error, stdout, stderr) => {
//         if (error) {
//           fileOutputCallback(null);
//           throw error;
//         } else {
//           const raw_output = stdout.split('\n')
//           fileOutputCallback({
//             num_lines: parseInt(raw_output[0]),
//             num_chars: parseInt(raw_output[1]),
//             num_letters: parseInt(raw_output[2]),
//           });
//           // output.num_lines = parseInt(raw_output[0])
//           // output.num_chars = parseInt(raw_output[1])
//           // output.num_letters = parseInt(raw_output[2])
//         }
//       }
//       );
// }

// const handleFileOpen = async () => {
//   const fileNamePromise = new DeferredPromise<string>(), fileProcessPromise = new DeferredPromise<FileOutput>();
//
//   const {canceled, filePaths} = await dialog.showOpenDialog({
//   })
//
//   if (canceled) {
//     fileNamePromise.reject();
//     //fileProcessPromise.reject();
//   } else {
//     const absolute_file_path = filePaths[0]
//     fileNamePromise.resolve(path.basename(absolute_file_path))
//   }
//
//   return [fileNamePromise, fileProcessPromise]
// };

const selectFile = async () => {
  const {canceled, filePaths} = await dialog.showOpenDialog({
  })
  if (canceled) {
    throw Error()
  }
  const absolute_file_path = filePaths[0]
  return {
    file_path: absolute_file_path,
    file_name: path.basename(absolute_file_path)
  }
}

const processFile = async (event: Electron.IpcMainInvokeEvent, filePath: string) => {
  return new Promise<FileOutput>((resolve, reject) => {
    execFile('./python_code/dist/file_processor', [filePath],
        (error, stdout, stderr) => {
          if (error) {
            reject(error);
          } else {
            const raw_output = stdout.split('\n')
            resolve({
              num_lines: parseInt(raw_output[0]),
              num_chars: parseInt(raw_output[1]),
              num_letters: parseInt(raw_output[2]),
            });
            // output.num_lines = parseInt(raw_output[0])
            // output.num_chars = parseInt(raw_output[1])
            // output.num_letters = parseInt(raw_output[2])
          }
        }
    );
  });
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  ipcMain.handle('selectFile', selectFile)
  ipcMain.handle('processFile', processFile)
  createWindow()
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});