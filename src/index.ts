import { app, BrowserWindow, dialog, ipcMain } from 'electron';
import * as path from "path";
import {spawn, execFile} from "child_process"
import {DeferredPromise} from "./DeferredPromise";


declare global {
  type FileOutput = {
    num_lines: number,
    num_chars: number,
    num_letters: number,
  }

  interface Window {
    electronAPI: {
      openFile: (
            // fileNameCallback: FileNameCallback,
            // fileOutputCallback: FileOutputCallback
      ) => Promise<[DeferredPromise<string>, DeferredPromise<FileOutput>]>,// void
      selectFile: () => Promise<{file_path: string, file_name: string}>,
      processFile: (filePath: string) => Promise<FileOutput>,
    }
  }
}

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: any;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  // eslint-disable-line global-require
  app.quit();
}

const getExtraResourcePath = (fileName: string): string => {
  if (app.isPackaged) {
    return path.join(process.resourcesPath, 'extraResources', fileName)
  } else {
    return `./extraResources/${fileName}`
  }
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    }
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY).then();

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

const selectFile = async () => {
  const {canceled, filePaths} = await dialog.showOpenDialog({
  })
  if (canceled) {
    throw Error()
  }
  const absolute_file_path = filePaths[0]
  return {
    file_path: absolute_file_path,
    file_name: path.basename(absolute_file_path)
  }
}

const processFile = async (event: Electron.IpcMainInvokeEvent, filePath: string) => {
  return new Promise<FileOutput>((resolve, reject) => {
    execFile(getExtraResourcePath('file_processor'), [filePath],
        (error, stdout, stderr) => {
          if (error) {
            reject(error);
          } else {
            const raw_output = stdout.split('\n')
            resolve({
              num_lines: parseInt(raw_output[0]),
              num_chars: parseInt(raw_output[1]),
              num_letters: parseInt(raw_output[2]),
            });
          }
        }
    );
  });
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  ipcMain.handle('selectFile', selectFile)
  ipcMain.handle('processFile', processFile)
  createWindow()
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});