import {app, BrowserWindow, dialog, ipcMain} from 'electron';
import * as path from "path";
import {ChildProcess, execFile} from "child_process"


declare global {
  type FileOutput = {
    num_lines: number,
    num_chars: number,
    num_letters: number,
  }

  type Output = {
    error: boolean,
    time: number,
    message: {
      type: string,
      message: string,
    },
  }

  interface Window {
    electronAPI: {
      selectFile: () => Promise<{file_path: string, file_name: string}>,
      processFile: (filePath: string) => Promise<FileOutput>,
      startExec: (input: string) => void,
      onExecStart: (callback: (event: Electron.IpcRendererEvent, time: Date) => void) => void,
      onExecOutput: (callback: (event: Electron.IpcRendererEvent, output: Output) => void) => void,
      onExecEnd: (callback: (event: Electron.IpcRendererEvent, error: boolean) => void) => void,
    }
  }
}

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: any;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  // eslint-disable-line global-require
  app.quit();
}

const getExtraResourcePath = (fileName: string): string => {
  if (app.isPackaged) {
    return path.join(process.resourcesPath, 'extraResources', fileName)
  } else {
    return `./extraResources/${fileName}`
  }
}

let mainWindow: BrowserWindow;
const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    }
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY).then();

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

const selectFile = async () => {
  const {canceled, filePaths} = await dialog.showOpenDialog({
  })
  if (canceled) {
    throw Error()
  }
  const absolute_file_path = filePaths[0]
  return {
    file_path: absolute_file_path,
    file_name: path.basename(absolute_file_path)
  }
}

let child_process: ChildProcess = null;
const processFile = async (event: Electron.IpcMainInvokeEvent, filePath: string) => {
  if (child_process != null) {
    child_process.kill();
    console.log('killed process early');
  }
  return new Promise<FileOutput>((resolve, reject) => {
    child_process = execFile(getExtraResourcePath('file_processor'), [filePath],
        (error, stdout, stderr) => {
          child_process = null;
          if (error) {
            reject(error);
          } else {
            const raw_output = stdout.split('\n')
            resolve({
              num_lines: parseInt(raw_output[0]),
              num_chars: parseInt(raw_output[1]),
              num_letters: parseInt(raw_output[2]),
            });
          }
        }
    );
  });
}

let currentlyRunning = false;
let startTime = 0;
const startExec = (event: Electron.IpcMainEvent, input: string) => {
  if (!currentlyRunning) {
    currentlyRunning = true
    startTime = Date.now()
    mainWindow.webContents.send('start', new Date());
    execFile(getExtraResourcePath('file_processor'), [input],
        (error, stdout, stderr) => {
          currentlyRunning = false
          const output: Output = {
            time: (Date.now() - startTime)/1000,
            error: undefined,
            message: undefined,
          };
          if (stderr) {
            output.error = true
            try {
              output.message = JSON.parse(stderr)
            } catch (e) {
              output.message = {
                type: "N/A",
                message: stdout
              }
            }
          } else {
            output.error = false
            output.message = {
              type: undefined,
              message: stdout
            }
          }
          mainWindow.webContents.send('output', output);
          mainWindow.webContents.send('end', error !== null || stderr);
        })
  }
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  ipcMain.handle('selectFile', selectFile)
  ipcMain.handle('processFile', processFile)
  ipcMain.handle('startExec', startExec)
  createWindow()
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});